21. TCP协议
```
三次握手

假设 A 为客户端，B 为服务器端。
1. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
2. A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
3. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
4. A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
5. B 收到 A 的确认后，连接建立。

三次握手的原因
第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

TCP 的四次挥手
1. A 发送连接释放报文，FIN=1。
2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
3. 当 B 不再需要连接时，发送连接释放报文，FIN=1。
4. A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
5. B 收到 A 的确认后释放连接。

四次挥手的原因
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。
这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：
1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

HTTP 请求页面
1. 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。
2. 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。
3. HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。
4. 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。
5. HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。
6. 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

TCP的字节流如何在表示层进行封装？

粘包现象
1. 定义
发送方发送的若干数据包到接收端时粘成了一个包，表现为后一个包的头紧挨着上一个包的尾
2. 原因
    2.1 发送方：Nagle算法，只有上一个分组得到确认才会发送下一个分组；多个小分组时，收集到一起再发送
    2.2 接收方：接手之后不会马上送往应用层，而是缓存起来等待应用程序来主动读取。
3. 解决方法
如果发送的分组是毫不相关的关系，那就要处理粘包问题。
1. 发送方关闭Nagle算法。
2. 接收方在应用层进行处理，设计一种数据格式能分辨该数据分组的开始和结束；或者在发送数据的前面加上该数据的长度。

怎么处理

半连接、半打开、半关闭
1. 半连接：发生在TCP3次握手中。如果A向B发起TCP请求，B也按照正常情况进行响应了，但是A不进行第3次握手，这就是半连接。
半连接攻击：半连接，会造成B分配的内存资源就一直这么耗着，直到资源耗尽。
2. 半打开（Half-Open）：如果一方已经关闭或异常终止连接，而另一方却不知道。 
3. 半关闭：TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这就是TCP的半关闭。当一方关闭发送通道后，仍可接受另一方发送过来的数据，这样的情况叫“半关闭”。（拆除TCP连接是：你关闭你的发送通道，我关闭我的发送通道）。
    半关闭的产生
    1. 客户端发送FIN，另一端发送对这个FIN的ACK报文段。 此时客户端就处于半关闭。
    2. 调用shutdown，shutdown的第二个参数为SHUT_WR时，为半关闭。
    
服务端主动关闭连接会有什么后果？(原文：https://blog.csdn.net/bit_clearoff/article/details/60884905 )
当服务器进程被终止时，会关闭其打开的所有文件描述符，此时就会向客户端发送一个FIN 的报文,客户端则响应一个ACK 报文,但是这样只完成了“四次挥手”的前两次挥手，也就是说这样只实现了半关闭，客户端仍然可以向服务器写入数据。 
但是当客户端向服务器写入数据时，由于服务器端的套接字进程已经终止，此时连接的状态已经异常了，所以服务端进程不会向客户端发送ACK 报文，而是发送了一个RST 报文请求将处于异常状态的连接复位，
如果客户端此时还要向服务端发送数据，将诱发服务端TCP向服务端发送SIGPIPE信号，因为向接收到RST的套接口写数据都会收到此信号.
所以说，这就是为什么我们主动关闭服务端后，用客户端向服务端写数据，还必须是写两次后连接才会关闭的原因。

Nagle算法
TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。
Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。

```

5. 进程和线程
```
linux查看命令
top、ps

进程状态
1. 就绪状态（ready）：等待被调度
2. 运行状态（running）
3. 阻塞状态（waiting）：等待资源

进程间通信的方式：
1. 管道（只能在父子进程间通信）
2. FIFO（克服了上述缺点，用于C-S架构）
3. 消息队列
4. 信号量 （锁—生产者消费者问题）
5. 共享存储（最快，需要信号量来控制）
6. socket (网络通信)

线程间通信方式
1. 使用全局变量
2. 使用消息实现通信
3. 使用事件CEvent类实现线程间通信

线程间同步
1. 临界区
2. 互斥量
3. 信号量（与互斥量不同的是它可以同一时刻允许多个线程访问同一个资源）
4. 事件

进程同步
1. 临界区
2. 同步（顺序执行）与互斥（限制进入临界区的数量）
3. 信号量（消费者与生产者）
int mutex = 1; 
void func1(){
    down(&mutex);
    //do something
    up(&mutex);
}
void func2(){
    down(&mutex);
    //do something
    up(&mutex);
}
4. 管程

多线程优点
1. 所有线程可以直接共享内存和变量等； 
2. 线程方式消耗的总资源比进程方式好，

多线程缺点
1. 线程之间的同步和加锁控制比较麻烦； 
2. 一个线程的崩溃可能影响到整个程序的稳定性； 

多进程优点
1. 每个进程互相独立，不影响主程序的稳定性，子进程崩溃没关系；
2. 可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系；

多进程缺点
1. 逻辑控制复杂，需要和主程序交互； 
2. 多进程调度开销比较大； 
```


7. socket通信
```
ip地址＋协议＋端口号，唯一标示网络中的一个进程

socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信

socket常用函数

初始化一个socket（用什么协议）
int socket(int domain, int type, int protocol);

绑定地址（ip + 端口）
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

监听
int listen(int sockfd, int backlog);

client尝试连接
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

server接受连接（阻塞）
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

读操作
ssize_t read(int fd, void *buf, size_t count);

写操作
ssize_t write(int fd, const void *buf, size_t count);

关闭连接
int close(int fd);

```


10. 孤儿进程和僵尸进程
```
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
```


12. 进程和线程
```
进程是资源分配的基本单位，线程是任务调度的基本单位，一个进程里面可以包含多个线程，这些线程共享该进程的资源。
进程的切换比较开销大，线程则更轻量。
```

13. 匿名管道
```
匿名管道的局限性：

第一：匿名管道只能实现本地进程之间的通信，不能实现跨网络之间的进程间的通信。
第二：匿名管道只能实现父进程和子进程之间的通信，而不能实现任意两个本地进程之间的通信。


匿名管道的使用：

匿名管道主要用于本地父进程和子进程之间的通信，
在父进程中的话，首先是要创建一个匿名管道，
在创建匿名管道成功后，可以获取到对这个匿名管道的读写句柄，
然后父进程就可以向这个匿名管道中写入数据和读取数据了，
但是如果要实现的是父子进程通信的话，那么还必须在父进程中创建一个子进程，
同时，这个子进程必须能够继承和使用父进程的一些公开的句柄，
为什么呢？
因为在子进程中必须要使用父进程创建的匿名管道的读写句柄，
通过这个匿名管道才能实现父子进程的通信，所以必须继承父进程的公开句柄。
同时在创建子进程的时候，
必须将子进程的标准输入句柄设置为父进程中创建匿名管道时得到的读管道句柄，
将子进程的标准输出句柄设置为父进程中创建匿名管道时得到的写管道句柄。
然后在子进程就可以读写匿名管道了。
```
17. 死锁
```
必要条件：
1. 互斥，一个资源要么已分配，要么是处于可用的状态
2. 不可抢占： 一个资源被占用时不能被抢走，只能等它主动释放
3. 占有和等待：占有资源的同时可以请求其它的资源
4. 形成环路

处理方法
鸵鸟策略（不管）
死锁检测与死锁恢复（检测有向图是否存在环，杀死一个进程）
死锁预防（破坏四个必要条件）
死锁避免

```

14. 守护进程与nohup
```
守护进程的特点
守护进程(Daemon)是在后台运行的一种特殊进程，它脱离于终端，从而这可避免进程被任何终端所产生的信号打断，它在执行进程中的产生信息也不在任何终端上显示。守护进程周期性地执行某种任务或等待处理某些发生的事件，Linux的大多数服务器就是用守护进程实现的。

后台进程与守护进程
1、守护进程已经完全脱离终端控制台了，而后台程序并未完全脱离终端(在终端未关闭前还是会往终端输出结果);
2、守护进程在关闭终端控制台时不会受影响，而后台程序会随用户退出而停止，需要在以nohup command & 格式运行才能避免影响;　　
3、守护进程的会话组和当前目录，文件描述符都是独立的。后台运行只是终端进行了一次fork，让程序在后台执行，这些都没改变;　　
```

28. 硬链接与软链接的联系与区别
```
文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。
    用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方
    而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode号即索引节点号）才是文件的唯一标识而非文件名。
文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。
filename-->inode | userdata

由于硬链接是有着相同 inode 号仅文件名不同的文件，因此硬链接存在以下几点特性：
1. 文件有相同的 inode 及 data block；
2. 只能对已存在的文件进行创建；
3. 不能交叉文件系统进行硬链接的创建；
4. 不能对目录进行创建，只可对文件创建；
5. 删除一个硬链接文件并不影响其他有相同 inode 号的文件。

软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块（见 图 2.）。因此软链接的创建与使用没有类似硬链接的诸多限制：
1. 软链接有自己的文件属性及权限等；
2. 可对不存在的文件或目录创建软链接；
3. 软链接可交叉文件系统；
4. 软链接可对文件或目录创建；
5. 创建软链接时，链接计数 i_nlink 不会增加；
6. 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。
```
![image](https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/image002.jpg)

1. linux 查看文件内容的命令[linux命令]
```
cat, tac, more, less, head, tail, nl,
```

15. Linux中在当前目录下找出占用空间最大的前10大文件[linux命令]
```
inux中在当前目录下找出占用空间最大的前10大文件

du：

-a：显示目录占用空间的大小，还要显示其下目录占用空间的大小

sort：
-n  : 按照字符串表示的数字值来排序

-r ：按照反序排列

head :

-n : 取出前多少行

以上的问题可以使用命令： du -a | sort -n -r | head -n 10

```

24. 如何查看磁盘容量，cpu用量，各端口号[linux命令]
```
cat /proc/cpuinfo

cat /proc/meminfo

df -h # 查看各分区使用情况
du -sh # 查看指定目录的大小
fdisk -l # 查看所有分区

netstat –apn # 查看所有的进程和端口使用情况

ps -aux | grep tomcat # 发现并没有8080端口的Tomcat进程

```
